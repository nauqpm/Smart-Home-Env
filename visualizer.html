<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home 3D Visualizer - v4.4 (Fixed createMat Scope)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #f0f0f0;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab; /* Add mouse cursor */
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicking through */
            z-index: 10;
        }

        /* === CSS FOR 3D LABELS === */
        .label {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap; /* Prevent line breaks */
        }
        .label-soc { /* Battery label */
            color: #64ffda;
            border-color: #64ffda;
        }
        .label-pv { /* PV label */
            color: #ffd700;
            border-color: #ffd700;
        }
        .label-occupancy { /* Occupancy label */
            color: #f0f0f0;
            font-size: 16px;
        }
        /* === END CSS FOR 3D LABELS === */

        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            max-height: 95vh;
            background: rgba(28, 37, 65, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 11; /* Above label-container */
        }

        h2, h3 {
            color: #64ffda;
            border-bottom: 2px solid #3a506b;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-label {
            font-weight: 600;
            color: #8899a6;
        }

        .info-value {
            font-weight: bold;
            font-size: 18px;
            color: #64ffda;
        }

        #timestep-display {
            font-size: 32px;
            font-weight: bold;
            color: #64ffda;
            text-align: center;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }

        /* Battery Display */
        #battery-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 8px;
        }

        #battery-fill {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #64ffda, #667eea);
            border-radius: 12px;
            transition: all 0.5s ease;
        }

        /* Device Status Grid */
        #device-status {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .device-icon {
            font-size: 32px;
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
            transition: all 0.3s ease;
        }

        .device-on {
            color: #64ffda;
            background: rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.4);
        }

        .device-off {
            color: #506a8e;
        }

        /* Controls */
        #controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        #timeline {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #667eea, #764ba2);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #64ffda;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.8);
        }

        .buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 12px;
            gap: 8px;
        }

        .buttons button {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 80px;
            border-radius: 15px;
            z-index: 1000;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="label-container"></div>
    <div id="ui-panel">
        <h2>üè† Smart Home 3D</h2>
        <div id="timestep-display">Gi·ªù: 0</div>
        <div class="info-item">
            <span class="info-label">üå¶Ô∏è Th·ªùi ti·∫øt</span>
            <span class="info-value" id="weather">---</span>
        </div>
        <div class="info-item">
            <span class="info-label">üë• Ng∆∞·ªùi trong nh√†</span>
            <span class="info-value" id="occupancy">0/4</span>
        </div>
        <h3>üîã Pin nƒÉng l∆∞·ª£ng</h3>
        <div class="info-item">
            <span class="info-label">SOC</span>
            <span class="info-value" id="soc">50%</span>
        </div>
        <div id="battery-bar"><div id="battery-fill"></div></div>
        <h3>‚ö° NƒÉng l∆∞·ª£ng</h3>
        <div class="info-item">
            <span class="info-label">‚òÄÔ∏è PV</span>
            <span class="info-value" style="color: #ffd700;" id="pv">0.00 kW</span>
        </div>
        <div class="info-item">
            <span class="info-label">üìä T·∫£i</span>
            <span class="info-value" style="color: #ff8c00;" id="load">0.00 kW</span>
        </div>
        <div class="info-item">
            <span class="info-label">üîå L∆∞·ªõi</span>
            <span class="info-value" style="color: #ff6b6b;" id="grid">0.00 kW</span>
        </div>
        <h3>üîå Thi·∫øt b·ªã</h3>
        <div id="device-status">
            <div class="device-icon device-off" id="light-icon" data-device="lights">üí°</div>
            <div class="device-icon device-off" id="fridge-icon" data-device="fridge">üßä</div>
            <div class="device-icon device-off" id="tv-icon" data-device="tv">üì∫</div>
            <div class="device-icon device-off" id="ac-icon" data-device="ac">‚ùÑÔ∏è</div>
            <div class="device-icon device-off" id="heater-icon" data-device="heater">üî•</div>
            <div class="device-icon device-off" id="washing-icon" data-device="washing_machine">üß∫</div>
            <div class="device-icon device-off" id="dishwasher-icon" data-device="dishwasher">üçΩÔ∏è</div>
            <div class="device-icon device-off" id="laptop-icon" data-device="laptop">üíª</div>
            <div class="device-icon device-off" id="ev-icon" data-device="ev_charger">üöó</div>
        </div>
        <h3>üéõÔ∏è ƒêi·ªÅu khi·ªÉn</h3>
        <div id="controls">
            <input type="range" min="0" max="23" value="0" id="timeline">
            <div class="buttons">
                <button id="play-btn">‚ñ∂Ô∏è Play</button>
                <button id="pause-btn">‚è∏Ô∏è Pause</button>
                <button id="reset-btn">üîÑ Reset</button>
            </div>
        </div>
    </div>
    <div class="loading" id="loading">‚è≥ ƒêang t·∫£i m√¥ ph·ªèng...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let labelRenderer;
        let houseGroup, devices3D = {}, devices3D_labels = {};
        let batteryGroup, batteryFill, batteryLabelElement;
        let solarPanel, solarPanelLabelElement;
        let occupancyLabelElement;
        let sun3D, sunGlow, cloudGroup = [], rain, lightningFlash;
        let ambientLight, sunLight, hemisphereLight;
        let currentTime = 0;
        let isPlaying = false;
        let simulationInterval = null;
        let SIMULATION_DATA = {};
        const ui = {};

        // === FIX: Move createMat to global scope ===
        const createMat = (color) => new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, metalness: 0.2 });

        init();

        function init() {
            // Scene, Camera, Renderer, Controls, Label Renderer, Lighting, Ground, Helpers setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3a7d44);
            // scene.fog = new THREE.Fog(0x87ceeb, 40, 100); // B·ªé S∆Ø∆†NG M√ô
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 200);
            camera.position.set(20, 18, 20); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 10; controls.maxDistance = 80; controls.maxPolarAngle = Math.PI / 2.1;
            const labelContainer = document.getElementById('label-container');
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px';
            labelContainer.appendChild(labelRenderer.domElement);

            // TƒÇNG √ÅNH S√ÅNG CHUNG
            ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xdddddd, 0.6); scene.add(hemisphereLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 0.7); sunLight.position.set(30, 40, 20); sunLight.castShadow = true; sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048; sunLight.shadow.camera.left = -25; sunLight.shadow.camera.right = 25; sunLight.shadow.camera.top = 25; sunLight.shadow.camera.bottom = -25; scene.add(sunLight);

            // B·ªé M·∫∂T ƒê·∫§T XANH
            // const groundGeo = new THREE.PlaneGeometry(60, 60); const groundMat = new THREE.MeshStandardMaterial({ color: 0x3a7d44, roughness: 0.8 }); const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);

            // B·ªé L∆Ø·ªöI
            // const gridHelper = new THREE.GridHelper(60, 60, 0x555555, 0x555555); gridHelper.position.y = 0.01; scene.add(gridHelper);

            // B·ªé KHUNG TR·ª§C T·ªåA ƒê·ªò
            // const axesHelper = new THREE.AxesHelper(5); axesHelper.position.y = 0.01; scene.add(axesHelper);

            // Create 3D elements
            createWeatherSystem();
            createHouse(); // Create house with detailed layout
            createFurniture(); // Create furniture
            createBattery();
            createSolarPanel();
            createGridConnection();
            createAllDevices(); // Place devices in the house with furniture

            // Setup controls
            cacheUIElements();
            setupControls();
            window.addEventListener('resize', onWindowResize);

            // Load JSON data immediately
            loadDataAndStart();
            animate();
        }

        // Data loading function remains the same
        function loadDataAndStart() {
            fetch('simulation_data.json?t=' + new Date().getTime())
                .then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}.`); return response.json(); })
                .then(data => { SIMULATION_DATA = data; document.getElementById('timeline').max = data.timesteps.length - 1; document.getElementById('loading').style.display = 'none'; updateVisualization(0); })
                .catch(e => { console.error('Error loading simulation data:', e); document.getElementById('loading').textContent = '‚ùå Error loading data!'; });
        }

        // Weather system functions remain the same
        function createWeatherSystem() { const sunGeo = new THREE.SphereGeometry(4, 32, 32); const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); sun3D = new THREE.Mesh(sunGeo, sunMat); sun3D.position.set(40, 35, -30); scene.add(sun3D); const glowGeo = new THREE.SphereGeometry(4.5, 32, 32); const glowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 }); sunGlow = new THREE.Mesh(glowGeo, glowMat); sun3D.add(sunGlow); for (let i = 0; i < 15; i++) { const cloud = createCloud(); cloud.position.set(Math.random() * 50 - 25, 15 + Math.random() * 10, Math.random() * 50 - 25); cloud.visible = false; cloudGroup.push(cloud); scene.add(cloud); } const rainCount = 5000; const rainGeo = new THREE.BufferGeometry(); const positions = new Float32Array(rainCount * 3); const velocities = new Float32Array(rainCount); for (let i = 0; i < rainCount; i++) { positions[i * 3] = Math.random() * 50 - 25; positions[i * 3 + 1] = Math.random() * 40; positions[i * 3 + 2] = Math.random() * 50 - 25; velocities[i] = 0.2 + Math.random() * 0.3; } rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3)); rainGeo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1)); const rainMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.15, transparent: true, opacity: 0.6 }); rain = new THREE.Points(rainGeo, rainMat); rain.visible = false; scene.add(rain); lightningFlash = new THREE.PointLight(0xccccff, 0, 60); lightningFlash.position.set(0, 30, 0); scene.add(lightningFlash); }
        function createCloud() { const cloud = new THREE.Group(); const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 }); for (let i = 0; i < 3; i++) { const size = 1.5 + Math.random() * 1; const sphere = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 12), cloudMat); sphere.position.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 2); cloud.add(sphere); } return cloud; }

        // House creation function remains the same
        function createHouse() {
            houseGroup = new THREE.Group();
            scene.add(houseGroup);
            const floorGeo = new THREE.BoxGeometry(12, 0.3, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x9b7653 }); // M√ÄU ƒê·∫§T
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.receiveShadow = true;
            houseGroup.add(floor);
            // T∆Ø·ªúNG TR·∫ÆNG TINH, KH√îNG TRONG SU·ªêT
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
            const wallHeight = 3.0;
            const wallThick = 0.15;
            function createWall(w, d, x, z, angle = 0) { const wall = new THREE.Mesh(new THREE.BoxGeometry(w, wallHeight, d), wallMat); wall.position.set(x, wallHeight / 2 + 0.15, z); wall.rotation.y = angle; wall.castShadow = false; wall.receiveShadow = false; houseGroup.add(wall); } createWall(12 + wallThick, wallThick, 0, -5); createWall(12 + wallThick, wallThick, 0, 5); createWall(10 + wallThick, wallThick, -6, 0, Math.PI / 2); createWall(10 + wallThick, wallThick, 6, 0, Math.PI / 2); createWall(5, wallThick, -3.5, 2.5); createWall(5, wallThick, -1, 0, Math.PI / 2); createWall(5, wallThick, -2, -2.5); createWall(5, wallThick, 2, -2.5); createWall(2, wallThick, -5, -4, Math.PI / 2); createWall(2, wallThick, -4, -3);
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-occupancy';
            labelDiv.textContent = 'S·ªë ng∆∞·ªùi: 0';
            occupancyLabelElement = labelDiv;
            const occupancyLabel = new THREE.CSS2DObject(labelDiv);
            occupancyLabel.position.set(-6.5, 2, 0);
            houseGroup.add(occupancyLabel);

            // B·ªé ƒê∆Ø·ªúNG VI·ªÄN (WIREFRAME) C·ª¶A NG√îI NH√Ä
            // const houseEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(12, wallHeight, 10));
            // const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
            // const houseWireframe = new THREE.LineSegments(houseEdges, edgeMaterial);
            // houseWireframe.position.y = wallHeight / 2 + 0.15;
            // houseGroup.add(houseWireframe);
        }

        // Furniture creation function remains the same (uses global createMat)
        function createFurniture() {
            const furnitureGroup = new THREE.Group();
            const furnMat = createMat(0x8B4513); // Wood color
            const sofaMat = createMat(0x555555); // Dark sofa
            const bedMat = createMat(0x444466); // Bed color
            const tableMat = createMat(0x967969); // Lighter table
            const deskMat = createMat(0x7a5a4a); // Desk
            const sofa = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.7, 0.8), sofaMat); sofa.position.set(4, 0.7/2 + 0.15, -4); sofa.castShadow = true; furnitureGroup.add(sofa);
            const coffeeTable = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.6), tableMat); coffeeTable.position.set(0, 0.4/2 + 0.15, -2.5); coffeeTable.castShadow = true; furnitureGroup.add(coffeeTable);
            const armchair1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 0.8), sofaMat); armchair1.position.set(-0.5, 0.7/2 + 0.15, -1.0); armchair1.castShadow = true; furnitureGroup.add(armchair1);
            const armchair2 = armchair1.clone(); armchair2.position.set(0.5, 0.7/2 + 0.15, -1.0); furnitureGroup.add(armchair2);
            const diningTable = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.75, 1.0), tableMat); diningTable.position.set(-4, 0.75/2 + 0.15, 3.5); diningTable.castShadow = true; furnitureGroup.add(diningTable);
            const chairGeo = new THREE.BoxGeometry(0.4, 0.45, 0.4); const chairBackGeo = new THREE.BoxGeometry(0.4, 0.5, 0.05); function createChair(x, z, angle) { const chair = new THREE.Group(); const seat = new THREE.Mesh(chairGeo, tableMat); seat.position.y = 0.45/2; const back = new THREE.Mesh(chairBackGeo, tableMat); back.position.set(0, 0.45/2 + 0.5/2, -0.175); chair.add(seat); chair.add(back); chair.position.set(x, 0.15 , z); chair.rotation.y = angle; chair.castShadow = true; return chair; } furnitureGroup.add(createChair(-3.2, 3.5, Math.PI / 2)); furnitureGroup.add(createChair(-4.8, 3.5, -Math.PI / 2)); furnitureGroup.add(createChair(-4, 2.8, 0)); furnitureGroup.add(createChair(-4, 4.2, Math.PI));
            const counter = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 0.6), deskMat); counter.position.set(-4.75, 0.8/2 + 0.15, 0.3); counter.castShadow = true; furnitureGroup.add(counter);
            const bed1 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2.0), bedMat); bed1.position.set(-4, 0.5/2 + 0.15, -3.5); bed1.castShadow = true; furnitureGroup.add(bed1);
            const dresser1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 0.5), furnMat); dresser1.position.set(-5.5, 0.7/2+0.15, -1.0); dresser1.castShadow = true; furnitureGroup.add(dresser1);
            const desk = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), deskMat); desk.position.set(4.0, 0.7/2 + 0.15, -4.0); desk.castShadow = true; furnitureGroup.add(desk);
            const officeChair = createChair(5.0, -4.0, Math.PI / 1.5); furnitureGroup.add(officeChair);
            const bed3 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2.0), bedMat); bed3.position.set(4, 0.5/2 + 0.15, 3.5); bed3.castShadow = true; furnitureGroup.add(bed3);
            const toilet = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.5), createMat(0xffffff)); toilet.position.set(-5.5, 0.6/2+0.15, -4.5); toilet.castShadow = true; furnitureGroup.add(toilet);
            houseGroup.add(furnitureGroup);
        }

        // Label creation helper function remains the same
        function createDeviceLabel(text, name) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.textContent = text;
            labelDiv.style.visibility = 'hidden'; // S·∫Ω ƒë∆∞·ª£c b·∫≠t trong updateVisualization
            const label = new THREE.CSS2DObject(labelDiv);
            devices3D_labels[name] = label;
            return label;
        }

        // ==================== HELPER T·∫†O VI·ªÄN HIGHLIGHT ====================
        function addOutlineGlow(object3D, color = 0x64ffda, scale = 1.15) {
            // Ch√∫ng ta ph·∫£i duy·ªát theo c√°ch n√†y ƒë·ªÉ tr√°nh l·∫∑p v√¥ h·∫°n
            // v√¨ traverse() s·∫Ω duy·ªát c·∫£ c√°c ƒë·ªëi t∆∞·ª£ng con M·ªöI ƒë∆∞·ª£c th√™m v√†o
            const meshesToAddOutline = [];
            object3D.traverse((child) => {
                if (child.isMesh) {
                    meshesToAddOutline.push(child);
                }
            });

            meshesToAddOutline.forEach(child => {
                const outlineMat = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.BackSide // Ch·ªâ render m·∫∑t sau
                });
                const outlineMesh = new THREE.Mesh(child.geometry, outlineMat);
                outlineMesh.scale.set(scale, scale, scale);
                outlineMesh.name = "outlineGlow"; // ƒê·∫∑t t√™n ƒë·ªÉ c√≥ th·ªÉ b·ªè qua n·∫øu c·∫ßn
                child.add(outlineMesh); // Th√™m vi·ªÅn l√†m con c·ªßa mesh g·ªëc
            });
        }

        // ==================== CREATE DEVICES - Repositioned ====================
        function createAllDevices() {
            // createMat is now defined globally

            // --- LIGHTS ---
            const lightGeo = new THREE.SphereGeometry(0.2, 16, 8); const lightMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x000000, emissiveIntensity: 0 });
            devices3D.light_living = new THREE.Mesh(lightGeo, lightMat.clone()); devices3D.light_living.position.set(2, 2.8, -2.5); const lightSourceLiving = new THREE.PointLight(0xffd700, 0, 6); devices3D.light_living.add(lightSourceLiving); devices3D.light_living.userData.lightSource = lightSourceLiving; const lightLabelLiving = createDeviceLabel('ƒê√®n PK: 0.00 kW', 'lights'); lightLabelLiving.position.set(0, 0.4, 0); devices3D.light_living.add(lightLabelLiving);
            devices3D.light_living.visible = true;
            houseGroup.add(devices3D.light_living);
            addOutlineGlow(devices3D.light_living);

            devices3D.light_kitchen = new THREE.Mesh(lightGeo, lightMat.clone()); devices3D.light_kitchen.position.set(-4, 2.8, 2.5); const lightSourceKitchen = new THREE.PointLight(0xffd700, 0, 6); devices3D.light_kitchen.add(lightSourceKitchen); devices3D.light_kitchen.userData.lightSource = lightSourceKitchen; const lightLabelKitchen = createDeviceLabel('ƒê√®n B·∫øp: 0.00 kW', 'lights'); lightLabelKitchen.position.set(0, 0.4, 0); devices3D.light_kitchen.add(lightLabelKitchen);
            devices3D.light_kitchen.visible = true;
            houseGroup.add(devices3D.light_kitchen);
            addOutlineGlow(devices3D.light_kitchen);

            devices3D.light_bed1 = new THREE.Mesh(lightGeo, lightMat.clone()); devices3D.light_bed1.position.set(-4, 2.8, -2.5); const lightSourceBed1 = new THREE.PointLight(0xffd700, 0, 5); devices3D.light_bed1.add(lightSourceBed1); devices3D.light_bed1.userData.lightSource = lightSourceBed1; const lightLabelBed1 = createDeviceLabel('ƒê√®n PN1: 0.00 kW', 'lights'); lightLabelBed1.position.set(0, 0.4, 0); devices3D.light_bed1.add(lightLabelBed1);
            devices3D.light_bed1.visible = true;
            houseGroup.add(devices3D.light_bed1);
            addOutlineGlow(devices3D.light_bed1);

            devices3D.light_bed3 = new THREE.Mesh(lightGeo, lightMat.clone()); devices3D.light_bed3.position.set(4, 2.8, 2.5); const lightSourceBed3 = new THREE.PointLight(0xffd700, 0, 5); devices3D.light_bed3.add(lightSourceBed3); devices3D.light_bed3.userData.lightSource = lightSourceBed3; const lightLabelBed3 = createDeviceLabel('ƒê√®n PN3: 0.00 kW', 'lights'); lightLabelBed3.position.set(0, 0.4, 0); devices3D.light_bed3.add(lightLabelBed3);
            devices3D.light_bed3.visible = true;
            houseGroup.add(devices3D.light_bed3);
            addOutlineGlow(devices3D.light_bed3);

            devices3D.lights = devices3D.light_living; devices3D_labels.lights = lightLabelLiving;

            // --- OTHER DEVICES ---
            const fridgeGeo = new THREE.BoxGeometry(0.8, 1.7, 0.7); devices3D.fridge = new THREE.Mesh(fridgeGeo, createMat(0xeeeeee)); devices3D.fridge.position.set(-5.5, 1.7/2 + 0.15, 1.5); devices3D.fridge.castShadow = true; const fridgeLabel = createDeviceLabel('T·ªß l·∫°nh: 0.00 kW', 'fridge'); fridgeLabel.position.set(0, 1.0, 0); devices3D.fridge.add(fridgeLabel);
            houseGroup.add(devices3D.fridge);
            addOutlineGlow(devices3D.fridge);

            const tvScreenGeo = new THREE.BoxGeometry(1.6, 0.9, 0.05); devices3D.tv = new THREE.Mesh(tvScreenGeo, createMat(0x111111)); devices3D.tv.position.set(0, 0.15 + 0.4 + 0.9/2, -4.7); devices3D.tv.castShadow = true; const tvLabel = createDeviceLabel('TV: 0.00 kW', 'tv'); tvLabel.position.set(0, 0.6, 0.1); devices3D.tv.add(tvLabel);
            devices3D.tv.visible = true;
            houseGroup.add(devices3D.tv);
            addOutlineGlow(devices3D.tv);

            const acGeo = new THREE.BoxGeometry(1.0, 0.35, 0.25); devices3D.ac = new THREE.Mesh(acGeo, createMat(0xf0f0f0)); devices3D.ac.position.set(5.8, 2.8, -2.5); devices3D.ac.rotation.y = -Math.PI / 2; devices3D.ac.castShadow = true; const acLabel = createDeviceLabel('AC: 0.00 kW', 'ac'); acLabel.position.set(0, 0.3, 0); devices3D.ac.add(acLabel);
            devices3D.ac.visible = true;
            houseGroup.add(devices3D.ac);
            addOutlineGlow(devices3D.ac);

            const heaterGeo = new THREE.BoxGeometry(0.6, 0.45, 0.35); devices3D.heater = new THREE.Mesh(heaterGeo, createMat(0xc0392b)); devices3D.heater.position.set(-5.5, 0.45/2 + 0.15, -1.5); devices3D.heater.castShadow = true; const heaterLabel = createDeviceLabel('S∆∞·ªüi: 0.00 kW', 'heater'); heaterLabel.position.set(0, 0.4, 0); devices3D.heater.add(heaterLabel);
            devices3D.heater.visible = true;
            houseGroup.add(devices3D.heater);
            addOutlineGlow(devices3D.heater, 0xff8c00); // Vi·ªÅn m√†u cam cho s∆∞·ªüi

            const washingGeo = new THREE.BoxGeometry(0.6, 0.8, 0.6); const washingDoorGeo = new THREE.CircleGeometry(0.2, 16); devices3D.washing_machine = new THREE.Group(); const bodyWash = new THREE.Mesh(washingGeo, createMat(0x95a5a6)); bodyWash.castShadow = true; const doorWash = new THREE.Mesh(washingDoorGeo, createMat(0x333333)); doorWash.position.set(0, 0, 0.6/2 + 0.01); devices3D.washing_machine.add(bodyWash); devices3D.washing_machine.add(doorWash); devices3D.washing_machine.position.set(-4.0, 0.8/2 + 0.15, -4.5); const washingLabel = createDeviceLabel('M√°y gi·∫∑t: 0.00 kW', 'washing_machine'); washingLabel.position.set(0, 0.5, 0); devices3D.washing_machine.add(washingLabel);
            devices3D.washing_machine.visible = true;
            houseGroup.add(devices3D.washing_machine);
            addOutlineGlow(devices3D.washing_machine);

            const dishGeo = new THREE.BoxGeometry(0.7, 0.75, 0.55); devices3D.dishwasher = new THREE.Mesh(dishGeo, createMat(0xf9f9f9)); devices3D.dishwasher.position.set(-4.0, 0.75/2 + 0.15, 0.3); devices3D.dishwasher.castShadow = true; const dishLabel = createDeviceLabel('R·ª≠a b√°t: 0.00 kW', 'dishwasher'); dishLabel.position.set(0, 0.5, 0); devices3D.dishwasher.add(dishLabel);
            devices3D.dishwasher.visible = true;
            houseGroup.add(devices3D.dishwasher);
            addOutlineGlow(devices3D.dishwasher);

            const laptopBaseGeo = new THREE.BoxGeometry(0.4, 0.03, 0.3); const laptopScreenGeo = new THREE.BoxGeometry(0.4, 0.3, 0.02); devices3D.laptop = new THREE.Group(); const base = new THREE.Mesh(laptopBaseGeo, createMat(0x555555)); base.castShadow = true; const screenLaptop = new THREE.Mesh(laptopScreenGeo, createMat(0x222222)); screenLaptop.position.set(0, 0.15, -0.14); screenLaptop.rotation.x = -Math.PI / 6; devices3D.laptop.add(base); devices3D.laptop.add(screenLaptop); devices3D.laptop.position.set(4.0, 0.15 + 0.7 + 0.03/2 , -4.0); devices3D.laptop.rotation.y = Math.PI / 4; const laptopLabel = createDeviceLabel('Laptop: 0.00 kW', 'laptop'); laptopLabel.position.set(0, 0.4, 0); devices3D.laptop.add(laptopLabel);
            devices3D.laptop.visible = true;
            houseGroup.add(devices3D.laptop);
            addOutlineGlow(devices3D.laptop);

            devices3D.ev_charger = new THREE.Group();
            devices3D.ev_charger.visible = true; // HI·ªÇN TH·ªä LU√îN
            const chargerGeo = new THREE.BoxGeometry(0.25, 0.5, 0.15); const carGeo = new THREE.BoxGeometry(1.8, 0.7, 0.9); const chargerBox = new THREE.Mesh(chargerGeo, createMat(0x666666)); chargerBox.position.set(7.5, 0.8, 3); chargerBox.castShadow = true; const carBox = new THREE.Mesh(carGeo, createMat(0xbf4040)); carBox.position.set(9.0, 0.7/2 + 0.1, 3); carBox.castShadow = true; devices3D.ev_charger.add(chargerBox); devices3D.ev_charger.add(carBox); const evLabel = createDeviceLabel('S·∫°c EV: 0.00 kW', 'ev_charger'); evLabel.position.set(0.5, 1.0, 0); chargerBox.add(evLabel); scene.add(devices3D.ev_charger);
            addOutlineGlow(devices3D.ev_charger, 0xff6b6b); // Vi·ªÅn m√†u ƒë·ªè cho EV
        }

        // (createBattery, createSolarPanel, createGridConnection, UI/Controls functions remain the same)
         function createBattery() {
            batteryGroup = new THREE.Group();
            batteryGroup.position.set(8, 0, -3);
            const totalHeight = 3;
            const capacityGeo = new THREE.CylinderGeometry(0.8, 0.8, totalHeight, 32, 1, true);
            const capacityMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, transparent: true, opacity: 0.3 });
            const batteryCapacity = new THREE.Mesh(capacityGeo, capacityMat);
            batteryCapacity.position.y = totalHeight / 2;
            batteryGroup.add(batteryCapacity);
            const fillGeo = new THREE.CylinderGeometry(0.7, 0.7, totalHeight, 32);
            const fillMat = new THREE.MeshStandardMaterial({ color: 0x64ffda, emissive: 0x64ffda, emissiveIntensity: 0.2 });
            batteryFill = new THREE.Mesh(fillGeo, fillMat);
            batteryFill.position.y = totalHeight / 2;
            batteryGroup.add(batteryFill);
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-soc';
            labelDiv.textContent = 'SOC: 50%';
            batteryLabelElement = labelDiv;
            const batteryLabel = new THREE.CSS2DObject(labelDiv);
            batteryLabel.position.set(0, totalHeight + 0.5, 0);
            batteryGroup.add(batteryLabel);
            scene.add(batteryGroup);
        }

         function createSolarPanel() {
            solarPanel = new THREE.Group();
            const panelGeo = new THREE.BoxGeometry(4, 0.1, 2.5);
            const panelMat = new THREE.MeshStandardMaterial({ color: 0x1a2536, metalness: 0.8, roughness: 0.2 });
            const panelMesh = new THREE.Mesh(panelGeo, panelMat);
            panelMesh.castShadow = true;
            solarPanel.add(panelMesh);
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-pv'; labelDiv.textContent = 'PV: 0.00 kW';
            solarPanelLabelElement = labelDiv;
            const pvLabel = new THREE.CSS2DObject(labelDiv);
            pvLabel.position.set(0, 0.5, 0);
            solarPanel.add(pvLabel);
            solarPanel.position.set(-3.5, 4.4, -2.5);
            solarPanel.rotation.y = Math.PI / 4;
            solarPanel.rotation.x = -0.4;
            houseGroup.add(solarPanel);
        }

         function createGridConnection() {
            const poleGeo = new THREE.CylinderGeometry(0.15, 0.15, 8, 12);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x593d2b });
            const gridPole = new THREE.Mesh(poleGeo, poleMat);
            gridPole.position.set(12, 4, -8);
            gridPole.castShadow = true;
            scene.add(gridPole);
        }

         function cacheUIElements() {
            ui.timestep = document.getElementById('timestep-display');
            ui.weather = document.getElementById('weather');
            ui.occupancy = document.getElementById('occupancy');
            ui.soc = document.getElementById('soc');
            ui.batteryFill = document.getElementById('battery-fill');
            ui.pv = document.getElementById('pv');
            ui.load = document.getElementById('load');
            ui.grid = document.getElementById('grid');
            ui.timeline = document.getElementById('timeline');
            ui.playBtn = document.getElementById('play-btn');
            ui.pauseBtn = document.getElementById('pause-btn');
            ui.resetBtn = document.getElementById('reset-btn');
            ui.deviceIcons = {};
            document.querySelectorAll('.device-icon').forEach(icon => {
                const deviceName = icon.dataset.device;
                if (deviceName) {
                    ui.deviceIcons[deviceName] = icon;
                }
            });
        }

         function setupControls() {
            ui.timeline.addEventListener('input', (e) => {
                pauseSimulation();
                const time = parseInt(e.target.value, 10);
                updateVisualization(time);
            });
            ui.playBtn.addEventListener('click', playSimulation);
            ui.pauseBtn.addEventListener('click', pauseSimulation);
            ui.resetBtn.addEventListener('click', resetSimulation);
        }

         function playSimulation() {
            if (isPlaying) return;
            isPlaying = true;
            ui.playBtn.textContent = '‚ñ∂Ô∏è Playing...'; advanceTime();
            simulationInterval = setInterval(advanceTime, 1500);
        }

         function pauseSimulation() {
            isPlaying = false;
            clearInterval(simulationInterval);
            simulationInterval = null;
            ui.playBtn.textContent = '‚ñ∂Ô∏è Play';
        }

         function resetSimulation() {
            pauseSimulation();
            updateVisualization(0);
        }
         function advanceTime() {
            let nextTime = (currentTime + 1) % (SIMULATION_DATA.timesteps?.length || 24);
            updateVisualization(nextTime);
        }

        // ==================== UPDATE LOGIC (Always Show Devices) ====================
        function updateVisualization(time) {
            if (!SIMULATION_DATA || !SIMULATION_DATA.timesteps || !SIMULATION_DATA.device_power || !SIMULATION_DATA.devices) {
                console.warn("Simulation data not fully ready, waiting...");
                return;
            }
            currentTime = time; const data = SIMULATION_DATA; const t = time;

            // --- 1. Update UI Panel ---
            ui.timestep.textContent = `Hour: ${t}`;
            ui.timeline.value = t;
            const weather = data.weather[t];
            ui.weather.textContent = weather.charAt(0).toUpperCase() + weather.slice(1);
            const occupancy = Math.round(data.occupancy[t] * 4);
            ui.occupancy.textContent = `${occupancy}/4`;
            if (occupancyLabelElement) {
                occupancyLabelElement.textContent = `Occupants: ${occupancy}`;
            }
            const soc = data.soc[t];
            ui.soc.textContent = `${Math.round(soc * 100)}%`;
            ui.batteryFill.style.width = `${soc * 100}%`;
            ui.pv.textContent = `${data.pv[t].toFixed(2)} kW`;
            ui.load.textContent = `${data.load[t].toFixed(2)} kW`;
            ui.grid.textContent = `${data.grid[t].toFixed(2)} kW`;

            // --- 2. Update Device Icons (UI) ---
            const devicesOn = data.devices[t];
            if (devicesOn) {
                for (const deviceName in devicesOn) {
                    const icon = ui.deviceIcons[deviceName];
                    if (icon) {
                        const isDeviceOn = devicesOn[deviceName];
                        icon.classList.toggle('device-on', isDeviceOn);
                        icon.classList.toggle('device-off', !isDeviceOn);
                    }
                }
            } else {
                console.warn(`Missing 'devices' data for timestep ${t}`);
            }

            // --- 3. Update 3D Scene ---
            // Battery
            const totalBatteryHeight = 3;
            batteryFill.scale.y = Math.max(0.001, soc);
            batteryFill.position.y = (soc * totalBatteryHeight / 2);
            if (batteryLabelElement) {
                batteryLabelElement.textContent = `SOC: ${Math.round(soc * 100)}%`;
            }

            // Devices & Labels
            const devicePower = data.device_power[t];
            if(devicePower && devicesOn) {
                // PV
                if (solarPanelLabelElement) {
                    const pvPower = devicePower.pv || 0;
                    solarPanelLabelElement.textContent = `PV: ${pvPower.toFixed(2)} kW`;
                    solarPanelLabelElement.style.visibility = (pvPower > 0.01) ? 'visible' : 'hidden';
                }

                const displayNameMap = {'lights': 'ƒê√®n', 'fridge': 'T·ªß l·∫°nh', 'tv': 'TV', 'ac': 'AC', 'heater': 'S∆∞·ªüi', 'washing_machine': 'M√°y gi·∫∑t', 'dishwasher': 'R·ª≠a b√°t', 'laptop': 'Laptop', 'ev_charger': 'S·∫°c EV'};

                // === Handle Multiple Lights ===
                const areLightsOn = devicesOn['lights'];
                const lightsPower = devicePower['lights'] || 0;
                ['light_living', 'light_kitchen', 'light_bed1', 'light_bed3'].forEach((lightKey, index) => {
                    const lightModel = devices3D[lightKey];
                    const lightLabel = devices3D_labels['lights'];
                    if (lightModel) {
                        lightModel.material.emissiveIntensity = areLightsOn ? 1 : 0;
                        if (lightModel.userData.lightSource) {
                            lightModel.userData.lightSource.intensity = areLightsOn ? 1.5 : 0;
                        }
                    }
                    if (lightLabel && lightKey === 'light_living') {
                        if (areLightsOn) {
                            lightLabel.element.textContent = `ƒê√®n (T·ªïng): ${lightsPower.toFixed(2)} kW`;
                            lightLabel.element.classList.add('label-soc');
                        } else {
                            lightLabel.element.textContent = `ƒê√®n: OFF`;
                            lightLabel.element.classList.remove('label-soc');
                        }
                        lightLabel.element.style.visibility = 'visible';
                    }
                });
                // === End Handle Lights ===


                // Update other devices (excluding lights)
                for (const key in devicesOn) {
                    if (key.startsWith('light_') || key === 'lights') continue;

                    const model = devices3D[key];
                    const label = devices3D_labels[key];
                    const isDeviceOn = devicesOn[key];

                    if (model) {
                         // B·ªé LOGIC L√ÄM M·ªú (OPACITY) KHI T·∫ÆT
                         // model.visible = true; // ƒê√£ set true khi kh·ªüi t·∫°o

                         // Specific ON effects (glows)
                         if (key === 'tv' && model.material) { // TV is now Mesh only
                             model.material.emissive.setHex(isDeviceOn ? 0x222255 : 0x000000);
                         } else if (key === 'laptop' && model.children[1]?.material) { // Laptop screen
                             model.children[1].material.emissive.setHex(isDeviceOn ? 0x9999ff : 0x000000);
                         }
                    }

                    // Update Labels
                    if (label) {
                        // LOGIC M·ªöI: LU√îN HI·ªÇN TH·ªä LABEL
                        const displayName = displayNameMap[key] || key.charAt(0).toUpperCase() + key.slice(1);
                        if (isDeviceOn) {
                            const power = devicePower[key] !== undefined ? devicePower[key] : 0;
                            label.element.textContent = `${displayName}: ${power.toFixed(2)} kW`;
                            label.element.classList.add('label-soc'); // Th√™m class cho s√°ng
                        } else {
                            label.element.textContent = `${displayName}: OFF`;
                            label.element.classList.remove('label-soc'); // B·ªè class s√°ng
                        }
                        label.element.style.visibility = 'visible'; // Lu√¥n hi·ªÉn th·ªã
                    }
                }
            } else { console.warn(`Missing 'device_power' or 'devices' data for timestep ${t}`); }

            // Update Weather
            updateWeather3D(weather, t);
        }

        // Weather update function (ƒê√É S·ª¨A ƒê·ªÇ LU√îN S√ÅNG V√Ä N·ªÄN TR·∫ÆNG)
        function updateWeather3D(weather, time) {
            rain.visible = false;
            // sunLight.intensity = 1.0; // S·∫Ω ƒë∆∞·ª£c ƒë·∫∑t trong logic b√™n d∆∞·ªõi
            sun3D.visible = true;
            sunGlow.visible = true;
            // hemisphereLight.intensity = 0.5; // S·∫Ω ƒë∆∞·ª£c ƒë·∫∑t trong logic b√™n d∆∞·ªõi
            if (lightningFlash.intensity > 0) lightningFlash.intensity = 0;

            const sunAngle = (time / 23) * Math.PI - (Math.PI / 2);
            sunLight.position.set(Math.cos(sunAngle) * 40, Math.sin(sunAngle) * 40 + 10, 20);
            sun3D.position.set(sunLight.position.x, sunLight.position.y, -30);

            // === LOGIC √ÅNH S√ÅNG M·ªöI ===
            // ƒê·∫∑t l·∫°i c∆∞·ªùng ƒë·ªô √°nh s√°ng c∆° b·∫£n (ph·∫£i kh·ªõp v·ªõi gi√° tr·ªã trong h√†m init())
            let baseSunIntensity = 0.7;
            let baseAmbientIntensity = 0.8;
            let baseHemiIntensity = 0.6;


            if (time < 6 || time > 18) {
                baseSunIntensity = 0.3; // Gi·∫£m √°nh n·∫Øng v√†o ban ƒë√™m, nh∆∞ng kh√¥ng t·∫Øt
                sun3D.visible = false; // ·∫®N M·∫∂T TR·ªúI KHI TR·ªúI T·ªêI
                sunGlow.visible = false;
            } else {
                baseSunIntensity = 0.7; // √Ånh n·∫Øng ban ng√†y
                sun3D.visible = true; // HI·ªÜN M·∫∂T TR·ªúI KHI TR·ªúI S√ÅNG
                sunGlow.visible = true;
            }

            // ƒê·∫∑t l·∫°i √°nh s√°ng tr∆∞·ªõc khi ƒëi·ªÅu ch·ªânh theo th·ªùi ti·∫øt
            ambientLight.intensity = baseAmbientIntensity;
            hemisphereLight.intensity = baseHemiIntensity;

            // KH√îNG THAY ƒê·ªîI scene.background ho·∫∑c scene.fog ·ªü ƒë√¢y n·ªØa

            switch(weather) {
                case 'sunny':
                    cloudGroup.forEach(c => c.visible = false);
                    sunLight.intensity = baseSunIntensity;
                    break;
                case 'mild':
                    cloudGroup.forEach((c, i) => c.visible = (i < 5));
                    sunLight.intensity = baseSunIntensity * 0.9;
                    break;
                case 'cloudy':
                    cloudGroup.forEach(c => c.visible = true);
                    sunGlow.visible = false;
                    ambientLight.intensity *= 0.9; // Gi·∫£m nh·∫π
                    sunLight.intensity = baseSunIntensity * 0.5; // Gi·∫£m n·∫Øng
                    hemisphereLight.intensity *= 0.9;
                    break;
                case 'rainy':
                    cloudGroup.forEach(c => c.visible = true);
                    sun3D.visible = false; sunGlow.visible = false;
                    rain.visible = true;
                    ambientLight.intensity *= 0.7; // T·ªëi h∆°n
                    sunLight.intensity = baseSunIntensity * 0.3; // √çt n·∫Øng
                    hemisphereLight.intensity *= 0.8;
                    break;
                case 'stormy':
                    cloudGroup.forEach(c => c.visible = true);
                    sun3D.visible = false; sunGlow.visible = false;
                    rain.visible = true;
                    ambientLight.intensity *= 0.5; // T·ªëi
                    sunLight.intensity = baseSunIntensity * 0.2; // G·∫ßn nh∆∞ kh√¥ng c√≥ n·∫Øng
                    hemisphereLight.intensity *= 0.6;
                    break;
                default:
                    cloudGroup.forEach(c => c.visible = false);
                    sunLight.intensity = baseSunIntensity;
            }
        }

        // Animation loop remains the same
        function animate() { requestAnimationFrame(animate); if (controls) controls.update(); if (SIMULATION_DATA && SIMULATION_DATA.weather && SIMULATION_DATA.weather[currentTime] !== undefined) { if (rain.visible) { const positions = rain.geometry.attributes.position.array; const velocities = rain.geometry.attributes.velocity.array; for (let i = 0; i < positions.length; i += 3) { positions[i + 1] -= velocities[i / 3]; if (positions[i + 1] < 0) { positions[i + 1] = 40; } } rain.geometry.attributes.position.needsUpdate = true; } if (SIMULATION_DATA.weather[currentTime] === 'stormy') { if (Math.random() > 0.98 && lightningFlash.intensity === 0) { lightningFlash.intensity = 20; } else if (lightningFlash.intensity > 0) { lightningFlash.intensity -= 1.5; } } cloudGroup.forEach(cloud => { if (cloud.visible) { cloud.position.x += 0.01; if (cloud.position.x > 30) { cloud.position.x = -30; } } }); } renderer.render(scene, camera); if (labelRenderer) labelRenderer.render(scene, camera); }
        // Resize handler remains the same
        function onWindowResize() { const container = document.getElementById('canvas-container'); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); if (labelRenderer) labelRenderer.setSize(container.clientWidth, container.clientHeight); }

    </script>
</body>
</html>