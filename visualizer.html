<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home 3D Visualizer (Floor Plan)</title>
    <style>
        /* CSS Gi·ªØ nguy√™n nh∆∞ c≈© */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #f0f0f0;
            display: flex;
            overflow: hidden;
        }
        #canvas-container { flex-grow: 1; height: 100vh; }
        #ui-panel {
            width: 300px;
            height: 100vh;
            background-color: #1c2541;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            border-left: 2px solid #3a506b;
        }
        h2, h3 { color: #64ffda; border-bottom: 1px solid #3a506b; padding-bottom: 5px; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .info-item { background-color: #2a3a5e; padding: 10px; border-radius: 5px; }
        .info-item strong { display: block; color: #8899a6; font-size: 0.8em; margin-bottom: 5px; }
        #soc-display { background-color: #2a3a5e; border-radius: 5px; padding: 10px; margin-bottom: 20px; }
        #battery-bar { width: 100%; height: 20px; background-color: #3a506b; border-radius: 3px; overflow: hidden; }
        #battery-fill { height: 100%; width: 50%; background: linear-gradient(90deg, #64ffda, #667eea); transition: width 0.3s ease, background 0.3s ease; }
        #device-status { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
        .device-icon { font-size: 24px; padding: 8px; border-radius: 5px; background-color: #2a3a5e; transition: all 0.2s ease; }
        .device-on { color: #64ffda; box-shadow: 0 0 10px #64ffda; }
        .device-off { color: #506a8e; }
        #controls { background-color: #2a3a5e; padding: 15px; border-radius: 5px; }
        #timeline { width: 100%; }
        .buttons { display: flex; justify-content: space-around; margin-top: 10px; }
        .buttons button { background-color: #64ffda; border: none; color: #1a1a2e; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .buttons button:hover { background-color: #8affea; }
        .loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 26, 46, 0.9); color: white; display: flex; justify-content: center; align-items: center; font-size: 2em; z-index: 1000; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="ui-panel">
        <h2>Smart Home 3D</h2>
        <div class="info-item">
            <strong>TH·ªúI GIAN: <span id="timestep-display">Gi·ªù: 0</span></strong>
            <div>Th·ªùi ti·∫øt: <span id="weather">---</span></div>
            <div>·ªû nh√†: <span id="occupancy">0/4</span></div>
        </div>
        <h3>Pin (Battery)</h3>
        <div id="soc-display">
            <strong>SOC: <span id="soc">50%</span></strong>
            <div id="battery-bar"><div id="battery-fill"></div></div>
        </div>
        <h3>Tr·∫°ng th√°i nƒÉng l∆∞·ª£ng</h3>
        <div class="info-grid">
            <div class="info-item"><strong>PV (kW)</strong><span id="pv">0.00</span></div>
            <div class="info-item"><strong>Load (kW)</strong><span id="load">0.00</span></div>
            <div class="info-item"><strong>Grid (kW)</strong><span id="grid">0.00</span></div>
        </div>
        <h3>Thi·∫øt b·ªã (Devices)</h3>
        <div id="device-status">
            <span id="light-icon" class="device-icon device-off">üí°</span>
            <span id="ac-icon" class="device-icon device-off">‚ùÑÔ∏è</span>
            <span id="heater-icon" class="device-icon device-off">üî•</span>
            <span id="tv-icon" class="device-icon device-off">üì∫</span>
            <span id="washing-icon" class="device-icon device-off">üß∫</span>
            <span id="ev-icon" class="device-icon device-off">üöó</span>
        </div>
        <h3>ƒêi·ªÅu khi·ªÉn (Controls)</h3>
        <div id="controls">
            <input type="range" min="0" max="23" value="0" class="slider" id="timeline">
            <div class="buttons">
                <button id="play-btn">Play</button>
                <button id="pause-btn">Pause</button>
                <button id="reset-btn">Reset</button>
            </div>
        </div>
    </div>
    <div class="loading" id="loading">ƒêang t·∫£i m√¥ ph·ªèng...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // Bi·∫øn to√†n c·ª•c
        let SIMULATION_DATA = {};
        let scene, camera, renderer, sunLight, ambientLight;
        let houseGroup, ground;
        let people = [];
        let batteryGroup, batteryFill, socText;
        let solarPanel;
        let rain, rainMaterial, lightningFlash; // Cho m∆∞a v√† s·∫•m s√©t
        let devices3D = {};

        // Bi·∫øn tr·∫°ng th√°i
        let currentTime = 0;
        let isPlaying = false;
        let animationSpeed = 1;

        // H√†m kh·ªüi t·∫°o
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

            // Camera (S·ª¨A L·ªñI: ƒê·∫∑t camera cao h∆°n ƒë·ªÉ xem m·∫∑t b·∫±ng)
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 18, 15); // Nh√¨n t·ª´ tr√™n cao, g√≥c ch√©o
            camera.lookAt(0, 0, 0); // Nh√¨n v√†o trung t√¢m

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // TƒÉng s√°ng m√¥i tr∆∞·ªùng
            scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0); // N·∫Øng
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            scene.add(sunLight);

            // N√ÇNG C·∫§P: √Ånh s√°ng s·∫•m s√©t (ban ƒë·∫ßu t·∫Øt)
            lightningFlash = new THREE.PointLight(0xccccff, 0, 100, 2);
            lightningFlash.position.set(0, 30, 0);
            scene.add(lightningFlash);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(60, 60);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2d4a3e, roughness: 0.8 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // T·∫£i Font v√† t·∫°o m√¥ h√¨nh
            loadFontAndModels();

            // T·∫°o hi·ªáu ·ª©ng m∆∞a (S·ª¨A L·ªñI)
            createRainEffect();

            // G·∫Øn c√°c s·ª± ki·ªán
            setupControls();
            window.addEventListener('resize', onWindowResize);

            // T·∫£i d·ªØ li·ªáu
            loadDataAndStart();
        }

        function loadFontAndModels() {
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                // N√ÇNG C·∫§P: X√¢y nh√† m·∫∑t b·∫±ng (kh√¥ng m√°i)
                createFloorPlanHouse();
                // N√ÇNG C·∫§P: ƒê·∫∑t thi·∫øt b·ªã v√†o ƒë√∫ng ph√≤ng
                createDevicesInHouse();

                createBattery(font);
                createPeople();
            }, undefined, (error) => {
                console.error("L·ªói t·∫£i font 3D:", error);
                createFloorPlanHouse();
                createDevicesInHouse();
                createBattery();
                createPeople();
            });
        }

        // ==========================================================
        // N√ÇNG C·∫§P: X√ÇY NH√Ä M·∫∂T B·∫∞NG (KH√îNG M√ÅI)
        // ==========================================================
        function createFloorPlanHouse() {
            houseGroup = new THREE.Group();
            scene.add(houseGroup);

            const wallHeight = 3.0; // Chi·ªÅu cao t∆∞·ªùng
            const wallThick = 0.2; // ƒê·ªô d√†y t∆∞·ªùng
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xdecba4 }); // M√†u s√†n g·ªó
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 }); // M√†u t∆∞·ªùng tr·∫Øng

            // 1. S√†n nh√† (Base)
            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(16, 0.2, 10), // R·ªông 16, S√¢u 10
                floorMat
            );
            floor.receiveShadow = true;
            houseGroup.add(floor);

            // 2. T∆∞·ªùng (T·ªça ƒë·ªô (x, y, z))
            // (H√†m tr·ª£ gi√∫p t·∫°o t∆∞·ªùng)
            function createWall(w, h, d, x, y, z) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                wall.position.set(x, y, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                houseGroup.add(wall);
                return wall;
            }

            // T∆∞·ªùng bao
            createWall(16, wallHeight, wallThick, 0, wallHeight/2, 5); // T∆∞·ªùng sau
            createWall(16, wallHeight, wallThick, 0, wallHeight/2, -5); // T∆∞·ªùng tr∆∞·ªõc
            createWall(wallThick, wallHeight, 10, -8, wallHeight/2, 0); // T∆∞·ªùng tr√°i
            createWall(wallThick, wallHeight, 10, 8, wallHeight/2, 0); // T∆∞·ªùng ph·∫£i

            // T∆∞·ªùng ngƒÉn
            // (M√¥ ph·ªèng 3 ph√≤ng ng·ªß + 1 P.Kh√°ch/B·∫øp + 1 P.T·∫Øm)
            // T∆∞·ªùng d·ªçc
            createWall(wallThick, wallHeight, 4, -3, wallHeight/2, 3); // T∆∞·ªùng P.Ng·ªß 1
            createWall(wallThick, wallHeight, 4, 1, wallHeight/2, 3);  // T∆∞·ªùng P.Ng·ªß 2
            createWall(wallThick, wallHeight, 4, 4, wallHeight/2, 3);  // T∆∞·ªùng P.T·∫Øm

            // T∆∞·ªùng ngang
            createWall(16, wallHeight, wallThick, 0, wallHeight/2, 1); // T∆∞·ªùng ngƒÉn ngang
            createWall(5, wallHeight, wallThick, 5.5, wallHeight/2, -2); // T∆∞·ªùng P.Ng·ªß 3
        }

        // ==========================================================
        // N√ÇNG C·∫§P: ƒê·∫∂T THI·∫æT B·ªä V√ÄO PH√íNG
        // ==========================================================
        function createDevicesInHouse() {
            // (V·∫≠t li·ªáu ph√°t s√°ng)
            const emissiveMat = (color) => new THREE.MeshStandardMaterial({ color: color, emissive: 0x000000 });

            // TV (ƒê·∫∑t ·ªü P.Kh√°ch)
            const tv = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 0.1), emissiveMat(0x34495e));
            tv.position.set(-5.5, 1, -4.9); // √Åp t∆∞·ªùng tr∆∞·ªõc
            devices3D.tv = tv;

            // AC (ƒêi·ªÅu h√≤a) (ƒê·∫∑t ·ªü P.Ng·ªß 1)
            const ac = new THREE.Mesh(new THREE.BoxGeometry(1, 0.4, 0.3), emissiveMat(0xecf0f1));
            ac.position.set(-5.5, 2.5, 4.9); // √Åp t∆∞·ªùng sau
            devices3D.ac = ac;

            // ƒê√®n (ƒê·∫∑t ·ªü tr·∫ßn P.Kh√°ch)
            const lightBulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 })
            );
            lightBulb.position.set(-5.5, 2.8, -2); // Tr·∫ßn P.Kh√°ch
            devices3D.lights = lightBulb;

            // M√°y s∆∞·ªüi (ƒê·∫∑t ·ªü P.Ng·ªß 2)
            const heater = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.3), emissiveMat(0xc0392b));
            heater.position.set(-1, 0.5, 4.8); // G√≥c P.Ng·ªß 2
            devices3D.heater = heater;

            // M√°y gi·∫∑t (ƒê·∫∑t ·ªü P.T·∫Øm)
            const washingMachine = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.8), emissiveMat(0x95a5a6));
            washingMachine.position.set(2.5, 0.5, 4); // G√≥c P.T·∫Øm
            devices3D.washing_machine = washingMachine;

            // Th√™m t·∫•t c·∫£ thi·∫øt b·ªã v√†o houseGroup
            Object.values(devices3D).forEach(device => {
                device.visible = false; // Ban ƒë·∫ßu ·∫©n
                device.castShadow = true;
                houseGroup.add(device);
            });

            // S·∫°c EV (ƒê·∫∑t b√™n ngo√†i, b√™n ph·∫£i nh√†)
            const evCharger = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.3), emissiveMat(0x2c3e50));
            evCharger.position.set(8.5, 0.6, 0); // G·∫Øn t∆∞·ªùng ngo√†i b√™n ph·∫£i
            evCharger.visible = false;
            devices3D.ev_charger = evCharger;
            scene.add(evCharger); // Th√™m v√†o scene (ngo√†i houseGroup)

            // Solar Panel (T·∫•m pin m·∫∑t tr·ªùi) (ƒê·∫∑t tr√™n b√£i c·ªè)
            solarPanel = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 3),
                new THREE.MeshStandardMaterial({ color: 0x1e3a8a, metalness: 0.8, roughness: 0.2, emissive: 0x000000 })
            );
            solarPanel.position.set(12, 0.1, 0); // ƒê·∫∑t ngo√†i s√¢n
            solarPanel.rotation.x = -Math.PI / 8;
            solarPanel.castShadow = true;
            scene.add(solarPanel);
        }

        function createBattery(font) {
            batteryGroup = new THREE.Group();
            batteryGroup.position.set(-10, 1, 0); // ƒê·∫∑t b√™n tr√°i nh√†
            scene.add(batteryGroup);

            const batteryOutline = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0x2ecc71 }));
            batteryOutline.castShadow = true;
            batteryGroup.add(batteryOutline);

            batteryFill = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 1.9, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x64ffda, emissive: 0x64ffda, emissiveIntensity: 0.3 })
            );
            batteryGroup.add(batteryFill);

            if (font) {
                const textGeometry = new THREE.TextGeometry('...%', { font: font, size: 0.3, height: 0.05 });
                textGeometry.computeBoundingBox();
                socText = new THREE.Mesh(textGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                socText.position.set(-0.4, 1.2, 0.26);
                batteryGroup.add(socText);
            }
        }

        function createPeople() {
            for (let i = 0; i < 4; i++) {
                const person = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3498db })
                );
                // ƒê·∫∑t h·ªç ·ªü P.Kh√°ch
                person.position.set(-6 + Math.random()*2, 0.6, -2 + Math.random()*2);
                person.visible = false;
                person.castShadow = true;
                houseGroup.add(person);
                people.push(person);
            }
        }

        // ==========================================================
        // S·ª¨A L·ªñI: HI·ªÜU ·ª®NG M∆ØA
        // ==========================================================
        function createRainEffect() {
            const rainCount = 10000; // TƒÉng s·ªë l∆∞·ª£ng h·∫°t
            const posArr = new Float32Array(rainCount * 3);
            const velArr = new Float32Array(rainCount); // M·∫£ng v·∫≠n t·ªëc r∆°i

            for (let i = 0; i < rainCount; i++) {
                posArr[i * 3 + 0] = (Math.random() * 40 - 20); // x
                posArr[i * 3 + 1] = (Math.random() * 30 + 5);  // y
                posArr[i * 3 + 2] = (Math.random() * 40 - 20); // z
                velArr[i] = 0.1 + Math.random() * 0.2; // T·ªëc ƒë·ªô r∆°i ng·∫´u nhi√™n
            }

            const rainGeometry = new THREE.BufferGeometry();
            rainGeometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            rainGeometry.setAttribute('velocity', new THREE.BufferAttribute(velArr, 1)); // L∆∞u t·ªëc ƒë·ªô

            // D√πng v·∫≠t li·ªáu c∆° b·∫£n, kh√¥ng c·∫ßn texture
            rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1, // K√≠ch th∆∞·ªõc h·∫°t
                transparent: true,
                opacity: 0.7
            });
            rain = new THREE.Points(rainGeometry, rainMaterial);
            rain.visible = false; // M·∫∑c ƒë·ªãnh ·∫©n
            scene.add(rain);
        }

        // ==========================================================
        // H√ÄM C·∫¨P NH·∫¨T CH√çNH (UPDATE VISUALIZATION)
        // ==========================================================
        function updateVisualization(timeIndex) {
            if (!SIMULATION_DATA || !SIMULATION_DATA.timesteps) return;
            const data = SIMULATION_DATA;
            timeIndex = Math.max(0, Math.min(timeIndex, data.timesteps.length - 1));

            // L·∫•y d·ªØ li·ªáu c·ªßa timestep hi·ªán t·∫°i
            const getEl = (id) => document.getElementById(id);
            const currentDevices = data.devices[timeIndex];
            const currentPV = data.pv[timeIndex];
            const currentLoad = data.load[timeIndex];
            const currentGrid = data.grid[timeIndex];
            const currentSOC = data.soc[timeIndex];
            const currentOccupancy = data.occupancy[timeIndex];
            const currentWeather = data.weather[timeIndex];

            // 1. C·∫≠p nh·∫≠t B·∫£ng ƒëi·ªÅu khi·ªÉn (UI Panel)
            getEl('timestep-display').textContent = `Gi·ªù: ${timeIndex}`;
            getEl('weather').textContent = currentWeather;
            getEl('occupancy').textContent = Math.round(currentOccupancy * 4) + '/4';
            getEl('soc').textContent = Math.round(currentSOC * 100) + '%';

            const batteryFillEl = getEl('battery-fill');
            batteryFillEl.style.width = (currentSOC * 100) + '%';
            if (currentSOC > 0.6) batteryFillEl.style.background = 'linear-gradient(90deg, #64ffda, #667eea)';
            else if (currentSOC > 0.3) batteryFillEl.style.background = 'linear-gradient(90deg, #ffd700, #ff8c00)';
            else batteryFillEl.style.background = 'linear-gradient(90deg, #ff6b6b, #c92a2a)';

            getEl('pv').textContent = currentPV.toFixed(2);
            getEl('load').textContent = currentLoad.toFixed(2);
            getEl('grid').textContent = currentGrid.toFixed(2);

            // 2. C·∫≠p nh·∫≠t Pin 3D (M√†u s·∫Øc & Ch·ªØ)
            if (batteryFill) {
                const newScale = Math.max(0.01, currentSOC);
                batteryFill.scale.y = newScale;
                batteryFill.position.y = (newScale * 1.9 / 2) - (1.9 / 2);

                if (currentSOC > 0.6) { batteryFill.material.color.setHex(0x64ffda); batteryFill.material.emissive.setHex(0x64ffda); }
                else if (currentSOC > 0.3) { batteryFill.material.color.setHex(0xffd700); batteryFill.material.emissive.setHex(0xffd700); }
                else { batteryFill.material.color.setHex(0xff6b6b); batteryFill.material.emissive.setHex(0xff6b6b); }
            }
            if (socText) {
                const newText = `${Math.round(currentSOC * 100)}%`;
                socText.geometry.dispose();
                socText.geometry = new THREE.TextGeometry(newText, { font: socText.geometry.parameters.font, size: 0.3, height: 0.05 });
                socText.geometry.computeBoundingBox();
                socText.position.x = - (socText.geometry.boundingBox.max.x - socText.geometry.boundingBox.min.x) / 2;
            }

            // 3. C·∫≠p nh·∫≠t Ng∆∞·ªùi 3D
            const numPeople = Math.round(currentOccupancy * 4);
            people.forEach((person, i) => {
                person.visible = i < numPeople;
            });

            // 4. C·∫≠p nh·∫≠t Thi·∫øt b·ªã 3D (B·∫≠t/T·∫Øt v√† Ph√°t s√°ng)
            for (const deviceKey in devices3D) {
                if (devices3D.hasOwnProperty(deviceKey) && currentDevices.hasOwnProperty(deviceKey)) {
                    const deviceMesh = devices3D[deviceKey];
                    const isOn = currentDevices[deviceKey];
                    deviceMesh.visible = isOn; // ·∫®n/hi·ªán

                    if (deviceMesh.material.emissive) {
                        let glowColor = 0x64ffda; // S√°ng xanh
                        if (deviceKey === 'heater') glowColor = 0xff4500; // S∆∞·ªüi s√°ng ƒë·ªè
                        if (deviceKey === 'tv') glowColor = 0x0000ff; // TV s√°ng xanh d∆∞∆°ng

                        deviceMesh.material.emissive.setHex(isOn ? glowColor : 0x000000);
                        deviceMesh.material.emissiveIntensity = isOn ? 1.0 : 0;
                    }
                }
            }

            // C·∫≠p nh·∫≠t icon 2D
            updateDeviceStatus('light-icon', currentDevices.lights);
            updateDeviceStatus('ac-icon', currentDevices.ac);
            updateDeviceStatus('heater-icon', currentDevices.heater);
            updateDeviceStatus('tv-icon', currentDevices.tv);
            updateDeviceStatus('washing-icon', currentDevices.washing_machine);
            updateDeviceStatus('ev-icon', currentDevices.ev_charger);

            // 5. C·∫≠p nh·∫≠t M√¥i tr∆∞·ªùng (Th·ªùi ti·∫øt)
            if (solarPanel) {
                solarPanel.material.emissive.setHex(currentPV > 0.1 ? 0x4444ff : 0x000000); // T·∫•m pin s√°ng xanh
            }

            let skyColor, fogColor, rainVisible = false;
            let ambientIntensity = 0.5;
            let sunIntensity = 1.0;

            switch (currentWeather) {
                case "sunny":
                    skyColor = 0x87ceeb; fogColor = 0x87ceeb;
                    ambientIntensity = 0.6; sunIntensity = 1.2;
                    break;
                case "mild":
                    skyColor = 0xa7d9f7; fogColor = 0xa7d9f7;
                    ambientIntensity = 0.5; sunIntensity = 0.8;
                    break;
                case "cloudy":
                    skyColor = 0x99a9b7; fogColor = 0x99a9b7;
                    ambientIntensity = 0.4; sunIntensity = 0.5;
                    break;
                case "rainy":
                    skyColor = 0x6c7a89; fogColor = 0x6c7a89;
                    ambientIntensity = 0.3; sunIntensity = 0.3;
                    rainVisible = true;
                    break;
                case "stormy":
                    skyColor = 0x3d4a5d; fogColor = 0x3d4a5d; // T·ªëi s·∫ßm
                    ambientIntensity = 0.1; sunIntensity = 0.1; // R·∫•t t·ªëi
                    rainVisible = true;
                    // S·∫•m s√©t s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong animate()
                    break;
                default:
                    skyColor = 0x1a1a2e; fogColor = 0x1a1a2e;
                    ambientIntensity = 0.4; sunIntensity = 0.4;
                    break;
            }
            scene.background.setHex(skyColor);
            scene.fog.color.setHex(fogColor);
            ambientLight.intensity = ambientIntensity;
            sunLight.intensity = sunIntensity;
            if (rain) rain.visible = rainVisible;
        }

        // (H√†m n√†y gi·ªØ nguy√™n)
        function updateDeviceStatus(iconId, isOn) {
            const icon = document.getElementById(iconId);
            if (!icon) return;
            if (isOn) {
                icon.classList.remove('device-off');
                icon.classList.add('device-on');
            } else {
                icon.classList.remove('device-on');
                icon.classList.add('device-off');
            }
        }

        // ==========================================================
        // V√íNG L·∫∂P ANIMATION (TH√äM M∆ØA R∆†I V√Ä S·∫§M S√âT)
        // ==========================================================
        function animate() {
            requestAnimationFrame(animate);

            const timeFloor = Math.floor(currentTime);

            if (isPlaying) {
                currentTime += 0.02 * animationSpeed;
                if (currentTime >= (SIMULATION_DATA.timesteps?.length || 24)) {
                    currentTime = 0;
                }
                document.getElementById('timeline').value = timeFloor;
                updateVisualization(timeFloor);
            }

            // Hi·ªáu ·ª©ng m∆∞a r∆°i (S·ª¨A L·ªñI: C·∫≠p nh·∫≠t Y)
            if (rain && rain.visible) {
                const positions = rain.geometry.attributes.position.array;
                const velocities = rain.geometry.attributes.velocity.array;
                const count = positions.length / 3;

                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 1] -= velocities[i]; // R∆°i theo t·ªëc ƒë·ªô
                    if (positions[i * 3 + 1] < -5) {
                        positions[i * 3 + 1] = 30; // Reset l√™n cao
                    }
                }
                rain.geometry.attributes.position.needsUpdate = true; // R·∫•t quan tr·ªçng
            }

            // N√ÇNG C·∫§P: Hi·ªáu ·ª©ng s·∫•m s√©t
            if (lightningFlash) {
                if (rain && rain.visible && SIMULATION_DATA.weather[timeFloor] === 'stormy') {
                    if (Math.random() > 0.97) { // 3% c∆° h·ªôi m·ªói frame
                        lightningFlash.intensity = 3.0; // S√°ng b·ª´ng
                    }
                }
                lightningFlash.intensity *= 0.92; // Gi·∫£m d·∫ßn
            }

            renderer.render(scene, camera);
        }

        // (C√°c h√†m x·ª≠ l√Ω s·ª± ki·ªán v√† t·∫£i d·ªØ li·ªáu gi·ªØ nguy√™n)
        function setupControls() {
            const timeline = document.getElementById('timeline');
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resetBtn = document.getElementById('reset-btn');

            if (timeline) timeline.addEventListener('input', (e) => {
                currentTime = parseInt(e.target.value);
                updateVisualization(currentTime);
            });
            if (playBtn) playBtn.addEventListener('click', () => { isPlaying = true; });
            if (pauseBtn) pauseBtn.addEventListener('click', () => { isPlaying = false; });
            if (resetBtn) resetBtn.addEventListener('click', () => {
                currentTime = 0;
                if (timeline) timeline.value = 0;
                isPlaying = false;
                updateVisualization(0);
            });
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            if (container) {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        function loadDataAndStart() {
            fetch('simulation_data.json')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}.`);
                    return response.json();
                })
                .then(data => {
                    SIMULATION_DATA = data;
                    document.getElementById('timeline').max = data.timesteps.length - 1;
                    document.getElementById('loading').style.display = 'none';
                    updateVisualization(0);
                    animate();
                })
                .catch(e => {
                    console.error('L·ªói t·∫£i simulation data:', e);
                    document.getElementById('loading').textContent = '‚ùå L·ªói t·∫£i d·ªØ li·ªáu!';
                });
        }

        // Kh·ªüi ch·∫°y
        init();
    </script>
</body>
</html>