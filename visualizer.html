<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home 3D Visualizer - v3.2 (Debug)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #f0f0f0;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab; /* Th√™m con tr·ªè chu·ªôt */
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Cho ph√©p click xuy√™n qua */
            z-index: 10;
        }

        /* === CSS CHO NH√ÉN 3D === */
        .label {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap; /* Kh√¥ng xu·ªëng d√≤ng */
        }
        .label-soc { /* Nh√£n pin */
            color: #64ffda;
            border-color: #64ffda;
        }
        .label-pv { /* Nh√£n PV */
            color: #ffd700;
            border-color: #ffd700;
        }
        .label-occupancy { /* Nh√£n Ng∆∞·ªùi */
            color: #f0f0f0;
            font-size: 16px;
        }
        /* === K·∫æT TH√öC CSS NH√ÉN 3D === */

        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            max-height: 95vh;
            background: rgba(28, 37, 65, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 11; /* N·∫±m tr√™n label-container */
        }

        h2, h3 {
            color: #64ffda;
            border-bottom: 2px solid #3a506b;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-label {
            font-weight: 600;
            color: #8899a6;
        }

        .info-value {
            font-weight: bold;
            font-size: 18px;
            color: #64ffda;
        }

        #timestep-display {
            font-size: 32px;
            font-weight: bold;
            color: #64ffda;
            text-align: center;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }

        /* Battery Display */
        #battery-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 8px;
        }

        #battery-fill {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #64ffda, #667eea);
            border-radius: 12px;
            transition: all 0.5s ease;
        }

        /* Device Status Grid */
        #device-status {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .device-icon {
            font-size: 32px;
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
            transition: all 0.3s ease;
        }

        .device-on {
            color: #64ffda;
            background: rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.4);
        }

        .device-off {
            color: #506a8e;
        }

        /* Controls */
        #controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        #timeline {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #667eea, #764ba2);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #64ffda;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.8);
        }

        .buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 12px;
            gap: 8px;
        }

        .buttons button {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 80px;
            border-radius: 15px;
            z-index: 1000;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="label-container"></div>
    <div id="ui-panel">
        <h2>üè† Smart Home 3D</h2>
        <div id="timestep-display">Gi·ªù: 0</div>
        <div class="info-item">
            <span class="info-label">üå¶Ô∏è Th·ªùi ti·∫øt</span>
            <span class="info-value" id="weather">---</span>
        </div>
        <div class="info-item">
            <span class="info-label">üë• Ng∆∞·ªùi trong nh√†</span>
            <span class="info-value" id="occupancy">0/4</span>
        </div>
        <h3>üîã Pin nƒÉng l∆∞·ª£ng</h3>
        <div class="info-item">
            <span class="info-label">SOC</span>
            <span class="info-value" id="soc">50%</span>
        </div>
        <div id="battery-bar"><div id="battery-fill"></div></div>
        <h3>‚ö° NƒÉng l∆∞·ª£ng</h3>
        <div class="info-item">
            <span class="info-label">‚òÄÔ∏è PV</span>
            <span class="info-value" style="color: #ffd700;" id="pv">0.00 kW</span>
        </div>
        <div class="info-item">
            <span class="info-label">üìä T·∫£i</span>
            <span class="info-value" style="color: #ff8c00;" id="load">0.00 kW</span>
        </div>
        <div class="info-item">
            <span class="info-label">üîå L∆∞·ªõi</span>
            <span class="info-value" style="color: #ff6b6b;" id="grid">0.00 kW</span>
        </div>
        <h3>üîå Thi·∫øt b·ªã</h3>
        <div id="device-status">
            <div class="device-icon device-off" id="light-icon" data-device="lights">üí°</div>
            <div class="device-icon device-off" id="fridge-icon" data-device="fridge">üßä</div>
            <div class="device-icon device-off" id="tv-icon" data-device="tv">üì∫</div>
            <div class="device-icon device-off" id="ac-icon" data-device="ac">‚ùÑÔ∏è</div>
            <div class="device-icon device-off" id="heater-icon" data-device="heater">üî•</div>
            <div class="device-icon device-off" id="washing-icon" data-device="washing_machine">üß∫</div>
            <div class="device-icon device-off" id="dishwasher-icon" data-device="dishwasher">üçΩÔ∏è</div>
            <div class="device-icon device-off" id="laptop-icon" data-device="laptop">üíª</div>
            <div class="device-icon device-off" id="ev-icon" data-device="ev_charger">üöó</div>
        </div>
        <h3>üéõÔ∏è ƒêi·ªÅu khi·ªÉn</h3>
        <div id="controls">
            <input type="range" min="0" max="23" value="0" id="timeline">
            <div class="buttons">
                <button id="play-btn">‚ñ∂Ô∏è Play</button>
                <button id="pause-btn">‚è∏Ô∏è Pause</button>
                <button id="reset-btn">üîÑ Reset</button>
            </div>
        </div>
    </div>
    <div class="loading" id="loading">‚è≥ ƒêang t·∫£i m√¥ ph·ªèng...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer, controls;
        let labelRenderer;
        let houseGroup, devices3D = {}, devices3D_labels = {}; // L∆∞u tr·ªØ m√¥ h√¨nh V√Ä nh√£n
        let batteryGroup, batteryFill, batteryLabelElement; // Nh√£n cho pin
        let solarPanel, solarPanelLabelElement; // Nh√£n cho PV
        let occupancyLabelElement; // Nh√£n cho s·ªë ng∆∞·ªùi

        let sun3D, sunGlow, cloudGroup = [], rain, lightningFlash;
        let ambientLight, sunLight, hemisphereLight;

        let currentTime = 0;
        let isPlaying = false;
        let simulationInterval = null;
        let SIMULATION_DATA = {};
        const ui = {};

        // Run Initialization
        init();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 40, 100);

            // Camera
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 200);
            camera.position.set(20, 18, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 80;
            controls.maxPolarAngle = Math.PI / 2.1;

            // Label Renderer
            const labelContainer = document.getElementById('label-container');
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelContainer.appendChild(labelRenderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            hemisphereLight = new THREE.HemisphereLight(0xbad8ff, 0x3a7d44, 0.5);
            scene.add(hemisphereLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(30, 40, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -25;
            sunLight.shadow.camera.right = 25;
            sunLight.shadow.camera.top = 25;
            sunLight.shadow.camera.bottom = -25;
            scene.add(sunLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(60, 60);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x3a7d44, roughness: 0.8 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Helpers
            const gridHelper = new THREE.GridHelper(60, 60, 0x555555, 0x555555);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.y = 0.01;
            scene.add(axesHelper);

            // Create 3D elements
            createWeatherSystem();
            createHouse();
            createBattery();
            createSolarPanel();
            createGridConnection();
            createAllDevices(); // B·∫Øt ƒë·∫ßu t·∫£i m√¥ h√¨nh

            // Setup controls
            cacheUIElements();
            setupControls();
            window.addEventListener('resize', onWindowResize);

            // T·∫£i JSON ngay l·∫≠p t·ª©c
            loadDataAndStart();
            animate();
        }

        // ==================== DATA LOADING ====================
        function loadDataAndStart() {
            fetch('simulation_data.json?t=' + new Date().getTime())
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}.`);
                    return response.json();
                })
                .then(data => {
                    SIMULATION_DATA = data;
                    document.getElementById('timeline').max = data.timesteps.length - 1;
                    document.getElementById('loading').style.display = 'none';
                    updateVisualization(0); // C·∫≠p nh·∫≠t l·∫ßn ƒë·∫ßu
                })
                .catch(e => {
                    console.error('L·ªói t·∫£i simulation data:', e);
                    document.getElementById('loading').textContent = '‚ùå L·ªói t·∫£i d·ªØ li·ªáu!';
                });
        }

        // ==================== WEATHER SYSTEM ====================
        function createWeatherSystem() {
            const sunGeo = new THREE.SphereGeometry(4, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            sun3D = new THREE.Mesh(sunGeo, sunMat);
            sun3D.position.set(40, 35, -30);
            scene.add(sun3D);
            const glowGeo = new THREE.SphereGeometry(4.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 });
            sunGlow = new THREE.Mesh(glowGeo, glowMat);
            sun3D.add(sunGlow);
            for (let i = 0; i < 15; i++) {
                const cloud = createCloud();
                cloud.position.set(Math.random() * 50 - 25, 15 + Math.random() * 10, Math.random() * 50 - 25);
                cloud.visible = false;
                cloudGroup.push(cloud);
                scene.add(cloud);
            }
            const rainCount = 5000;
            const rainGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(rainCount * 3);
            const velocities = new Float32Array(rainCount);
            for (let i = 0; i < rainCount; i++) {
                positions[i * 3] = Math.random() * 50 - 25;
                positions[i * 3 + 1] = Math.random() * 40;
                positions[i * 3 + 2] = Math.random() * 50 - 25;
                velocities[i] = 0.2 + Math.random() * 0.3;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainGeo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
            const rainMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.15, transparent: true, opacity: 0.6 });
            rain = new THREE.Points(rainGeo, rainMat);
            rain.visible = false;
            scene.add(rain);
            lightningFlash = new THREE.PointLight(0xccccff, 0, 60);
            lightningFlash.position.set(0, 30, 0);
            scene.add(lightningFlash);
        }

        function createCloud() {
            const cloud = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
            for (let i = 0; i < 3; i++) {
                const size = 1.5 + Math.random() * 1;
                const sphere = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 12), cloudMat);
                sphere.position.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 2);
                cloud.add(sphere);
            }
            return cloud;
        }

        // ==================== HOUSE ====================
        function createHouse() {
            houseGroup = new THREE.Group();
            scene.add(houseGroup);
            const floorGeo = new THREE.BoxGeometry(12, 0.3, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xd4a574 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.receiveShadow = true;
            houseGroup.add(floor);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3, transparent: true, opacity: 0.2 });
            const wallHeight = 3.5;
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(12, wallHeight, 0.2), wallMat);
            backWall.position.set(0, wallHeight/2, -5);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            houseGroup.add(backWall);
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, wallHeight, 10), wallMat);
            leftWall.position.set(-6, wallHeight/2, 0);
            leftWall.castShadow = true;
            houseGroup.add(leftWall);
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, wallHeight, 10), wallMat);
            rightWall.position.set(6, wallHeight/2, 0);
            rightWall.castShadow = true;
            houseGroup.add(rightWall);
            const divWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, wallHeight, 6), wallMat);
            divWall1.position.set(-2, wallHeight/2, 2);
            houseGroup.add(divWall1);
            const divWall2 = new THREE.Mesh(new THREE.BoxGeometry(6, wallHeight, 0.15), wallMat);
            divWall2.position.set(1, wallHeight/2, 0);
            houseGroup.add(divWall2);
            const roofGeo = new THREE.ConeGeometry(9, 2.5, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, transparent: true, opacity: 0.3 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = wallHeight + 1.25;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);
            const doorGeo = new THREE.BoxGeometry(1.2, 2.2, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1.1, 4.9);
            houseGroup.add(door);
            const windowGeo = new THREE.BoxGeometry(1.2, 1.2, 0.1);
            const windowMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.7, emissive: 0x000000 });
            const win1 = new THREE.Mesh(windowGeo, windowMat.clone());
            win1.position.set(-3, 2, 4.9);
            houseGroup.add(win1);
            const win2 = new THREE.Mesh(windowGeo, windowMat.clone());
            win2.position.set(3, 2, 4.9);
            houseGroup.add(win2);
            const houseEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(12, 3.5, 10));
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
            const houseWireframe = new THREE.LineSegments(houseEdges, edgeMaterial);
            houseWireframe.position.y = 3.5 / 2;
            houseGroup.add(houseWireframe);

            // Th√™m nh√£n "S·ªë ng∆∞·ªùi"
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-occupancy';
            labelDiv.textContent = 'S·ªë ng∆∞·ªùi: 0';
            occupancyLabelElement = labelDiv; // L∆∞u l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t
            const occupancyLabel = new THREE.CSS2DObject(labelDiv);
            occupancyLabel.position.set(-6.5, 2, 0); // ƒê·∫∑t b√™n c·∫°nh t∆∞·ªùng tr√°i
            houseGroup.add(occupancyLabel);
        }

        // ==================== H√ÄM T·∫†O NH√ÉN 3D ====================
        function createDeviceLabel(text, name) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.textContent = text;
            labelDiv.style.visibility = 'hidden'; // ·∫®n ban ƒë·∫ßu

            const label = new THREE.CSS2DObject(labelDiv);
            devices3D_labels[name] = label; // L∆∞u nh√£n l·∫°i
            return label;
        }

        // ==================== T·∫¢I M√î H√åNH 3D (.GLB) - C√ì DEBUG ====================
        function createAllDevices() {
            const gltfLoader = new THREE.GLTFLoader();
            const modelBaseUrl = "https://poly.pizza/m/";

            // H√†m x·ª≠ l√Ω l·ªói chi ti·∫øt
            const onLoadError = (deviceKey, url, error) => {
                console.error(`‚ùå L·ªói t·∫£i m√¥ h√¨nh GLB cho '${deviceKey}' t·ª´ URL: ${url}`, error);
                // T·∫°o kh·ªëi vu√¥ng m√†u ƒë·ªè thay th·∫ø
                 const errorGeo = new THREE.BoxGeometry(0.5, 1, 0.5); // Cao h∆°n ƒë·ªÉ d·ªÖ th·∫•y
                 const errorMat = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: true, opacity: 0.7});
                 const errorMesh = new THREE.Mesh(errorGeo, errorMat);
                 // ƒê·∫∑t v·ªã tr√≠ placeholder t∆∞∆°ng ·ª©ng (∆∞·ªõc l∆∞·ª£ng)
                 const positions = {
                     'fridge': [-5, 0.65, -4], 'tv': [-4.5, 1.2, -4.85], 'ac': [4, 3.1, -4.8],
                     'heater': [4, 0.4, 3.5], 'washing_machine': [-4.5, 0.7, 3.5],
                     'dishwasher': [-5.2, 0.6, -2.5], 'laptop': [-4, 0.85, 0.5],
                     'ev_charger_box': [7.5, 0.8, 3], 'ev_car': [9.5, 0.65, 2.5]
                 };
                 if (positions[deviceKey]) {
                     errorMesh.position.set(...positions[deviceKey]);
                     // Ch·ªâ th√™m v√†o houseGroup n·∫øu l√† thi·∫øt b·ªã trong nh√†
                     if (!deviceKey.startsWith('ev')) {
                        houseGroup.add(errorMesh);
                     } else {
                        scene.add(errorMesh); // EV ·ªü ngo√†i scene
                     }
                     console.log(`-> ƒê√£ th√™m placeholder m√†u ƒë·ªè cho ${deviceKey}`);
                 }
            };

            // H√†m t·∫£i chung
            function loadDevice(key, urlPath, scale, position, rotationY = 0, labelText, labelOffsetY = 1.0) {
                const fullUrl = modelBaseUrl + urlPath;
                gltfLoader.load(fullUrl, (gltf) => {
                    console.log(`‚úÖ T·∫£i th√†nh c√¥ng: ${key} t·ª´ ${fullUrl}`);
                    const model = gltf.scene;
                    model.scale.set(scale, scale, scale);
                    model.position.set(...position);
                    model.rotation.y = rotationY;
                    model.traverse(c => { c.castShadow = true; });
                    const label = createDeviceLabel(labelText, key);
                    label.position.set(0, labelOffsetY, 0);
                    model.add(label);
                    houseGroup.add(model); // Th√™m v√†o nh√†
                    devices3D[key] = model;
                    model.visible = false; // ·∫®n ban ƒë·∫ßu
                },
                undefined, // onProgress
                (error) => onLoadError(key, fullUrl, error));
            }

             // H√†m t·∫£i EV
            function loadEVCharger() {
                devices3D.ev_charger = new THREE.Group();
                devices3D.ev_charger.visible = false; // ·∫®n group ban ƒë·∫ßu
                const evLabel = createDeviceLabel('S·∫°c EV: 0.00 kW', 'ev_charger');
                evLabel.position.set(1.5, 1.5, 0); // G·∫ßn xe h∆°n
                devices3D.ev_charger.add(evLabel);

                const chargerUrl = modelBaseUrl + "b9Yj0mQy2p9";
                gltfLoader.load(chargerUrl, (gltf) => {
                    console.log(`‚úÖ T·∫£i th√†nh c√¥ng: EV Charger Box t·ª´ ${chargerUrl}`);
                    const chargerModel = gltf.scene;
                    chargerModel.scale.set(0.8, 0.8, 0.8);
                    chargerModel.position.set(7.5, 0.5, 3);
                    chargerModel.rotation.y = -Math.PI / 2;
                    chargerModel.traverse(c => { c.castShadow = true; });
                    devices3D.ev_charger.add(chargerModel);
                }, undefined, (error) => onLoadError('ev_charger_box', chargerUrl, error));

                const carUrl = modelBaseUrl + "b-YtAXR0i24";
                gltfLoader.load(carUrl, (gltf) => {
                     console.log(`‚úÖ T·∫£i th√†nh c√¥ng: EV Car t·ª´ ${carUrl}`);
                    const carModel = gltf.scene;
                    carModel.scale.set(1.2, 1.2, 1.2);
                    carModel.position.set(9.5, 0.15, 2.5);
                    carModel.rotation.y = -Math.PI / 2;
                    carModel.traverse(c => { c.castShadow = true; });
                    devices3D.ev_charger.add(carModel);
                }, undefined, (error) => onLoadError('ev_car', carUrl, error));

                scene.add(devices3D.ev_charger);
            }


            // üí° Lights (Gi·ªØ nguy√™n)
            const lightGeo = new THREE.SphereGeometry(0.25, 16, 16); const lightMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x000000, emissiveIntensity: 0 }); devices3D.lights = new THREE.Mesh(lightGeo, lightMat); devices3D.lights.position.set(0, 3.2, 0); const lightSource = new THREE.PointLight(0xffd700, 0, 8); devices3D.lights.add(lightSource); devices3D.lights.userData.lightSource = lightSource; const lightLabel = createDeviceLabel('ƒê√®n: 0.00 kW', 'lights'); lightLabel.position.set(0, 0.5, 0); devices3D.lights.add(lightLabel); houseGroup.add(devices3D.lights); devices3D.lights.visible = false; // ·∫®n ban ƒë·∫ßu

            // T·∫£i c√°c thi·∫øt b·ªã kh√°c
            console.log("B·∫Øt ƒë·∫ßu t·∫£i c√°c m√¥ h√¨nh GLB...");
            loadDevice('fridge', "65d7iI6S0A2", 1.5, [-5, 0.15, -4], Math.PI, 'T·ªß l·∫°nh: 0.00 kW', 2.0);
            loadDevice('tv', "a-X4-bnm2gE", 1.5, [-4.5, 0.8, -4.85], 0, 'TV: 0.00 kW', 1.0);
            loadDevice('ac', "a1S0-q0e-4-", 0.015, [4, 3, -4.8], 0, 'AC: 0.00 kW', 20);
            loadDevice('heater', "cpoV9aUT3Yi", 0.6, [4, 0.15, 3.5], -Math.PI / 2, 'S∆∞·ªüi: 0.00 kW', 1.0);
            loadDevice('washing_machine', "5Gz1-6-b8Lf", 1.4, [-4.5, 0.15, 3.5], Math.PI / 2, 'M√°y gi·∫∑t: 0.00 kW', 1.2);
            loadDevice('dishwasher', "c_jB03uD6g_", 0.012, [-5.2, 0.15, -2.5], Math.PI / 2, 'R·ª≠a b√°t: 0.00 kW', 60);
            loadDevice('laptop', "5-3-p9-n7-V", 0.5, [-4, 0.8, 0.5], 0, 'Laptop: 0.00 kW', 0.5);
            loadEVCharger(); // T·∫£i EV ri√™ng
            console.log("ƒê√£ g·ª≠i y√™u c·∫ßu t·∫£i t·∫•t c·∫£ m√¥ h√¨nh.");

        }

        // ==================== 3D BATTERY ====================
        function createBattery() {
            batteryGroup = new THREE.Group();
            batteryGroup.position.set(8, 0, -3);
            const totalHeight = 3;
            const capacityGeo = new THREE.CylinderGeometry(0.8, 0.8, totalHeight, 32, 1, true);
            const capacityMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, transparent: true, opacity: 0.3 });
            const batteryCapacity = new THREE.Mesh(capacityGeo, capacityMat); // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh l·ªói khai b√°o l·∫°i
            batteryCapacity.position.y = totalHeight / 2;
            batteryGroup.add(batteryCapacity);
            const fillGeo = new THREE.CylinderGeometry(0.7, 0.7, totalHeight, 32);
            const fillMat = new THREE.MeshStandardMaterial({ color: 0x64ffda, emissive: 0x64ffda, emissiveIntensity: 0.2 });
            batteryFill = new THREE.Mesh(fillGeo, fillMat);
            batteryFill.position.y = totalHeight / 2;
            batteryGroup.add(batteryFill);
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-soc';
            labelDiv.textContent = 'SOC: 50%';
            batteryLabelElement = labelDiv;
            const batteryLabel = new THREE.CSS2DObject(labelDiv);
            batteryLabel.position.set(0, totalHeight + 0.5, 0);
            batteryGroup.add(batteryLabel);
            scene.add(batteryGroup);
        }

        // ==================== SOLAR PANEL ====================
        function createSolarPanel() {
            solarPanel = new THREE.Group(); // Chuy·ªÉn th√†nh Group
            const panelGeo = new THREE.BoxGeometry(4, 0.1, 2.5);
            const panelMat = new THREE.MeshStandardMaterial({ color: 0x1a2536, metalness: 0.8, roughness: 0.2 });
            const panelMesh = new THREE.Mesh(panelGeo, panelMat);
            panelMesh.castShadow = true;
            solarPanel.add(panelMesh);
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label label-pv';
            labelDiv.textContent = 'PV: 0.00 kW';
            solarPanelLabelElement = labelDiv;
            const pvLabel = new THREE.CSS2DObject(labelDiv);
            pvLabel.position.set(0, 0.5, 0);
            solarPanel.add(pvLabel);
            solarPanel.position.set(-3.5, 4.4, -2.5);
            solarPanel.rotation.y = Math.PI / 4;
            solarPanel.rotation.x = -0.4;
            houseGroup.add(solarPanel); // Th√™m group v√†o nh√†
        }

        // ==================== GRID CONNECTION ====================
        function createGridConnection() {
            const poleGeo = new THREE.CylinderGeometry(0.15, 0.15, 8, 12);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x593d2b });
            const gridPole = new THREE.Mesh(poleGeo, poleMat); // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh l·ªói
            gridPole.position.set(12, 4, -8);
            gridPole.castShadow = true;
            scene.add(gridPole);
        }

        // ==================== UI & CONTROLS ====================
        function cacheUIElements() {
            ui.timestep = document.getElementById('timestep-display'); ui.weather = document.getElementById('weather'); ui.occupancy = document.getElementById('occupancy'); ui.soc = document.getElementById('soc'); ui.batteryFill = document.getElementById('battery-fill'); ui.pv = document.getElementById('pv'); ui.load = document.getElementById('load'); ui.grid = document.getElementById('grid'); ui.timeline = document.getElementById('timeline'); ui.playBtn = document.getElementById('play-btn'); ui.pauseBtn = document.getElementById('pause-btn'); ui.resetBtn = document.getElementById('reset-btn'); ui.deviceIcons = {}; document.querySelectorAll('.device-icon').forEach(icon => { const deviceName = icon.dataset.device; if (deviceName) { ui.deviceIcons[deviceName] = icon; } });
        }

        function setupControls() {
            ui.timeline.addEventListener('input', (e) => { pauseSimulation(); const time = parseInt(e.target.value, 10); updateVisualization(time); }); ui.playBtn.addEventListener('click', playSimulation); ui.pauseBtn.addEventListener('click', pauseSimulation); ui.resetBtn.addEventListener('click', resetSimulation);
        }
        function playSimulation() { if (isPlaying) return; isPlaying = true; ui.playBtn.textContent = '‚ñ∂Ô∏è Playing...'; advanceTime(); simulationInterval = setInterval(advanceTime, 1500); }
        function pauseSimulation() { isPlaying = false; clearInterval(simulationInterval); simulationInterval = null; ui.playBtn.textContent = '‚ñ∂Ô∏è Play'; }
        function resetSimulation() { pauseSimulation(); updateVisualization(0); }
        function advanceTime() { let nextTime = (currentTime + 1) % (SIMULATION_DATA.timesteps?.length || 24); updateVisualization(nextTime); }

        // ==================== UPDATE LOGIC ====================
        function updateVisualization(time) {
            // Tho√°t s·ªõm n·∫øu d·ªØ li·ªáu ch∆∞a s·∫µn s√†ng
            if (!SIMULATION_DATA || !SIMULATION_DATA.timesteps || !SIMULATION_DATA.device_power || !SIMULATION_DATA.devices) {
                console.warn("D·ªØ li·ªáu simulation ch∆∞a ƒë·∫ßy ƒë·ªß, ƒëang ch·ªù...");
                return;
            }

            currentTime = time;
            const data = SIMULATION_DATA;
            const t = time;

            // --- 1. Update UI Panel ---
            ui.timestep.textContent = `Gi·ªù: ${t}`;
            ui.timeline.value = t;
            const weather = data.weather[t];
            ui.weather.textContent = weather.charAt(0).toUpperCase() + weather.slice(1);

            const occupancy = Math.round(data.occupancy[t] * 4);
            ui.occupancy.textContent = `${occupancy}/4`;
            if (occupancyLabelElement) {
                occupancyLabelElement.textContent = `S·ªë ng∆∞·ªùi: ${occupancy}`;
            }

            const soc = data.soc[t];
            ui.soc.textContent = `${Math.round(soc * 100)}%`;
            ui.batteryFill.style.width = `${soc * 100}%`;
            ui.pv.textContent = `${data.pv[t].toFixed(2)} kW`;
            ui.load.textContent = `${data.load[t].toFixed(2)} kW`;
            ui.grid.textContent = `${data.grid[t].toFixed(2)} kW`;

            // --- 2. Update Device Icons (UI) ---
            const devicesOn = data.devices[t]; // {lights: true, tv: false, ...}
            if (devicesOn) {
                for (const deviceName in devicesOn) {
                    const icon = ui.deviceIcons[deviceName];
                    if (icon) {
                        const isDeviceOn = devicesOn[deviceName];
                        icon.classList.toggle('device-on', isDeviceOn);
                        icon.classList.toggle('device-off', !isDeviceOn);
                    }
                }
            } else {
                 console.warn(`Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu 'devices' cho timestep ${t}`);
            }


            // --- 3. Update 3D Scene ---
            // Update 3D Battery
            const totalBatteryHeight = 3;
            const fillHeight = soc * totalBatteryHeight;
            // ƒê·∫£m b·∫£o scale kh√¥ng √¢m
            batteryFill.scale.y = Math.max(0.001, soc);
            // T√≠nh to√°n l·∫°i v·ªã tr√≠ y ƒë·ªÉ ƒë√°y lu√¥n c·ªë ƒë·ªãnh
            batteryFill.position.y = (soc * totalBatteryHeight / 2);

            if (batteryLabelElement) {
                batteryLabelElement.textContent = `SOC: ${Math.round(soc * 100)}%`;
            }

            // Update 3D Devices & Labels
            const devicePower = data.device_power[t]; // {lights: 0.1, tv: 0.0, ...}

            if(devicePower && devicesOn) {
                 // C·∫≠p nh·∫≠t PV
                if (solarPanelLabelElement) {
                    const pvPower = devicePower.pv || 0;
                    solarPanelLabelElement.textContent = `PV: ${pvPower.toFixed(2)} kW`;
                    solarPanelLabelElement.style.visibility = (pvPower > 0.01) ? 'visible' : 'hidden'; // Ch·ªâ hi·ªán khi > 0.01
                }

                // Map t√™n thi·∫øt b·ªã sang t√™n hi·ªÉn th·ªã ti·∫øng Vi·ªát
                const displayNameMap = {'lights': 'ƒê√®n', 'fridge': 'T·ªß l·∫°nh', 'tv': 'TV', 'ac': 'AC', 'heater': 'S∆∞·ªüi', 'washing_machine': 'M√°y gi·∫∑t', 'dishwasher': 'R·ª≠a b√°t', 'laptop': 'Laptop', 'ev_charger': 'S·∫°c EV'};

                // C·∫≠p nh·∫≠t c√°c thi·∫øt b·ªã kh√°c
                for (const key in devicesOn) {
                    const model = devices3D[key];
                    const label = devices3D_labels[key];
                    const isDeviceOn = devicesOn[key];

                    // 1. ·∫®n/Hi·ªán m√¥ h√¨nh
                    if (model) {
                        model.visible = isDeviceOn;

                        // X·ª≠ l√Ω ƒë√®n
                        if (key === 'lights') {
                            model.material.emissiveIntensity = isDeviceOn ? 1 : 0;
                            model.userData.lightSource.intensity = isDeviceOn ? 2 : 0;
                        }
                    } else {
                        // N·∫øu model ch∆∞a t·∫£i xong, v·∫´n log ƒë·ªÉ bi·∫øt
                         if(isDeviceOn) console.log(`Model cho '${key}' ch∆∞a t·∫£i xong nh∆∞ng d·ªØ li·ªáu b√°o ON.`);
                    }


                    // 2. ·∫®n/Hi·ªán v√† c·∫≠p nh·∫≠t Nh√£n
                    if (label) {
                        if (isDeviceOn) {
                            const power = devicePower[key] || 0;
                            const displayName = displayNameMap[key] || key.charAt(0).toUpperCase() + key.slice(1);
                            label.element.textContent = `${displayName}: ${power.toFixed(2)} kW`;
                            // Ch·ªâ hi·ªán nh√£n n·∫øu c√¥ng su·∫•t > 0 (tr·ª´ t·ªß l·∫°nh lu√¥n hi·ªán)
                            label.element.style.visibility = (power > 0.01 || key === 'fridge') ? 'visible' : 'hidden';
                        } else {
                            label.element.style.visibility = 'hidden';
                        }
                    }
                }
            } else {
                 console.warn(`Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu 'device_power' ho·∫∑c 'devices' cho timestep ${t}`);
            }


            // Update 3D Weather
            updateWeather3D(weather, t);
        }

        // ==================== UPDATE WEATHER 3D ====================
        function updateWeather3D(weather, time) {
            rain.visible = false; sunLight.intensity = 1.0; sun3D.visible = true; sunGlow.visible = true; hemisphereLight.intensity = 0.5; if (lightningFlash.intensity > 0) lightningFlash.intensity = 0; const sunAngle = (time / 23) * Math.PI - (Math.PI / 2); sunLight.position.set(Math.cos(sunAngle) * 40, Math.sin(sunAngle) * 40 + 10, 20); sun3D.position.set(sunLight.position.x, sunLight.position.y, -30); if (time < 6 || time > 18) { ambientLight.intensity = 0.1; sunLight.intensity = 0; hemisphereLight.intensity = 0.2; scene.background.set(0x1a1a2e); scene.fog.color.set(0x1a1a2e); } else { ambientLight.intensity = 0.5; scene.background.set(0x87ceeb); scene.fog.color.set(0x87ceeb); } switch(weather) { case 'sunny': cloudGroup.forEach(c => c.visible = false); break; case 'mild': cloudGroup.forEach((c, i) => c.visible = (i < 5)); break; case 'cloudy': cloudGroup.forEach(c => c.visible = true); sunGlow.visible = false; ambientLight.intensity *= 0.7; sunLight.intensity *= 0.4; hemisphereLight.intensity = 0.4; scene.background.set(0xbdc3c7); scene.fog.color.set(0xbdc3c7); break; case 'rainy': cloudGroup.forEach(c => c.visible = true); sun3D.visible = false; sunGlow.visible = false; rain.visible = true; ambientLight.intensity *= 0.4; sunLight.intensity *= 0.2; hemisphereLight.intensity = 0.3; scene.background.set(0x7f8c8d); scene.fog.color.set(0x7f8c8d); break; case 'stormy': cloudGroup.forEach(c => c.visible = true); sun3D.visible = false; sunGlow.visible = false; rain.visible = true; ambientLight.intensity *= 0.2; sunLight.intensity *= 0.1; hemisphereLight.intensity = 0.2; scene.background.set(0x34495e); scene.fog.color.set(0x34495e); break; default: cloudGroup.forEach(c => c.visible = false); }
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); // C·∫≠p nh·∫≠t OrbitControls

            // Ch·ªâ ch·∫°y animation th·ªùi ti·∫øt/m∆∞a/s√©t n·∫øu c√≥ d·ªØ li·ªáu
            if (SIMULATION_DATA && SIMULATION_DATA.weather && SIMULATION_DATA.weather[currentTime]) {
                if (rain.visible) {
                    const positions = rain.geometry.attributes.position.array; const velocities = rain.geometry.attributes.velocity.array; for (let i = 0; i < positions.length; i += 3) { positions[i + 1] -= velocities[i / 3]; if (positions[i + 1] < 0) { positions[i + 1] = 40; } } rain.geometry.attributes.position.needsUpdate = true;
                }
                if (SIMULATION_DATA.weather[currentTime] === 'stormy') {
                    if (Math.random() > 0.98 && lightningFlash.intensity === 0) { lightningFlash.intensity = 20; } else if (lightningFlash.intensity > 0) { lightningFlash.intensity -= 1.5; }
                }
                cloudGroup.forEach(cloud => { if (cloud.visible) { cloud.position.x += 0.01; if (cloud.position.x > 30) { cloud.position.x = -30; } } });
            }

            renderer.render(scene, camera);
            if (labelRenderer) labelRenderer.render(scene, camera); // Render nh√£n
        }

        // ==================== RESIZE HANDLER ====================
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            if (labelRenderer) labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }

    </script>
</body>
</html>